<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
  <link rel="stylesheet" href="index.css">
  <link rel="stylesheet" href="static/css/prism.css">
</head>

<body>
  <div class="wrapper">
    <h1>Darin Minamoto</h1>
    <div class="links">
      <a href="./index.html">Home</a>
      <a href="./about.html">About</a>
      <a href="https://github.com/DarinM223">Github</a>
    </div>

    <div class="content">
      <h1 id="my-explanation-of-the-main-concepts-in-rust">My
      explanation of the main concepts in Rust</h1>
      <h3>Date: December 3, 2015</h3>
      <p>There are three main concepts with Rust:</p>
      <ol type="1">
      <li>Ownership (only one variable “owns” the data at one time, and
      the owner is in charge of deallocating)</li>
      <li>Borrowing (you can borrow a reference to an owned
      variable)</li>
      <li>Lifetimes (all data keeps track of when it will be
      destroyed)</li>
      </ol>
      <p>These are fairly simple concepts, but they are often
      counter-intuitive to concepts in other languages, so I wanted to
      give a shot at explaining these concepts in more detail. Because
      Rust is not the only language that uses these concepts (you can do
      unique_ptr in C++ for example), learning these concepts will not
      just help you write better Rust code but better code in
      general.</p>
      <p>Note: I don’t cover Rust syntax here so if you cannot
      understand the syntax try to skim through the short online Rust
      book first https://doc.rust-lang.org/stable/book/</p>
      <h2 id="ownership">Ownership</h2>
      <p>The concept of ownership is that if you own an item, you are in
      charge of destroying the item when you are done.</p>
      <p>In Rust there can only be <strong>one</strong> owner of a piece
      of data at any time. This is a lot different from garbage
      collected languages or languages with raw pointers because instead
      of having multiple references to the same data, you often have to
      “juggle” around data so that only one variable owns the data at
      one time.</p>
      <p>Owned data is only automatically deleted when the owned
      variable no longer holds the data. This can happen when:</p>
      <ol type="1">
      <li>The owner variable goes out of scope and is destroyed</li>
      <li>The owner variable is set to another value, making the
      original data no longer accessable</li>
      </ol>
      <p>This simplifies the memory management problem and eliminates
      the confusing ‘which pointer should delete the data at the end?’
      problem that happens often in C or old C++. Ownership is not
      unique to Rust. Modern C++ recommends using ‘unique_ptr’, a smart
      pointer that also “owns” the data it wraps, over raw pointers.</p>
      <p>When you declare a variable in Rust, the variable “owns” the
      data.</p>
      <div class="sourceCode" id="cb1"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">2</span>)<span class="op">;</span> <span class="co">// a &quot;owns&quot; a heap allocated integer</span></span></code></pre></div>
      <p>When a variable owns something it can move it to other
      variables using assignment. After giving away its data, the old
      variable cannot access the value anymore, and the new variable is
      the new owner.</p>
      <div class="sourceCode" id="cb2"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mufasa <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="st">&quot;king&quot;</span>)<span class="op">;</span> <span class="co">// mufasa is the owner of &quot;king&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scar <span class="op">=</span> mufasa<span class="op">;</span> <span class="co">// the data &quot;king&quot; is moved from mufasa to scar</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> scar)<span class="op">;</span> <span class="co">// scar is now the owner of &quot;king&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> mufasa)<span class="op">;</span> <span class="co">// ERROR: mufasa can no longer be accessed</span></span></code></pre></div>
      <p>At the end of the scope where the owner is created, the data is
      destroyed</p>
      <div class="sourceCode" id="cb3"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">2</span>)<span class="op">;</span> <span class="co">// a owns a heap allocated integer</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// a&#39;s data deallocated here</span></span></code></pre></div>
      <p>Tips &amp; Tricks:</p>
      <ul>
      <li>Passing values into functions will “move” the data into the
      function variable. Once that happens the original variable cannot
      be accessed. This seems pretty restrictive, which is why the next
      topic tries to solve this.</li>
      </ul>
      <div class="sourceCode" id="cb4"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> hello(a<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    println(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> a)<span class="op">;</span> <span class="co">// prints &quot;2&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    hello(b)<span class="op">;</span> <span class="co">// moves b into hello&#39;s a parameter</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    b<span class="op">;</span> <span class="co">// ERROR: cannot access b after it gave its value to a</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <ul>
      <li>A common theme when working with Rust is that when data is
      enclosed by a container like a Vec<Foo> or an Option<Blah>, if you
      want to get the data out you have to either manually clone the
      data or remove it from the container first. One problem is that
      sometimes you want to move out data out of a container without
      preventing the container variable from being accessed. To do that,
      you can use the mem::replace function, which “resets” the variable
      to a certain value and returns the owned data. Afterwards the
      original owned variable no longer owns the data and the variable
      set to the return value now owns the data. For example, here is a
      code snippet for a linked list:</li>
      </ul>
      <div class="sourceCode" id="cb5"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>mem<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Link<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    data<span class="op">:</span> T<span class="op">,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    next<span class="op">:</span> Link<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Stack<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    size<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    head<span class="op">:</span> Link<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> Stack<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... other methods</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> pop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> head <span class="op">=</span> <span class="pp">mem::</span>replace(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>head<span class="op">,</span> <span class="cn">None</span>)<span class="op">;</span> <span class="co">// retrieve the Node from the Option and and set self.head to be None</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        head<span class="op">.</span>map(<span class="op">|</span>old_head<span class="op">|</span> <span class="op">{</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> old_head <span class="op">=</span> <span class="op">*</span>old_head<span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>head <span class="op">=</span> old_head<span class="op">.</span>next<span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>size <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            old_head<span class="op">.</span>data</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <p>Because this case is especially common with Options, there is a
      take() method for Options that does the same thing but is less
      verbose:</p>
      <div class="sourceCode" id="cb6"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> Stack<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... other methods</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> pop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>head<span class="op">.</span>take()<span class="op">.</span>map(<span class="op">|</span>old_head<span class="op">|</span> <span class="op">{</span> <span class="co">// retrieve the Node from the Option and set self.head to be None</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> old_head <span class="op">=</span> <span class="op">*</span>old_head<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>head <span class="op">=</span> old_head<span class="op">.</span>next<span class="op">;</span> <span class="co">// self.head is None so you can freely set it</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>size <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            old_head<span class="op">.</span>data</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h2 id="borrowing">Borrowing</h2>
      <p>The previous section highlighted a big flaw with ownership by
      itself. There are many cases where you want to manipulate data,
      without actually owning the data. For example you might want to
      pass a value to a function and still be able to call the owner
      variable outside the function.</p>
      <p>Rust allows you to do this using the concept of borrowing.
      Borrowing is just like what you think it is, it just allows
      another variable to temporarily borrow the data in your variable
      and gives it back when its done.</p>
      <p>Rust allows you to have two types of borrows:</p>
      <ul>
      <li>immutable borrows with ‘&amp;’ (you can read the value of the
      borrowed data, but you can’t modify it)</li>
      <li>mutable borrows with ‘&amp;mut’ (you can both read and modify
      the value of the borrowed data)</li>
      </ul>
      <p>You can either have:</p>
      <ul>
      <li>A lot of immutable borrows</li>
      <li>Only one mutable borrow</li>
      </ul>
      <p>in a scope for a piece of data at any given time. So you should
      try to do immutable borrows most of the time and only do a mutable
      borrow when you really need it.</p>
      <p>To access the value in a borrowed reference you use the
      dereference operator ’*’.</p>
      <p>When you borrow a variable, the owner variable becomes
      inaccessable until the borrowed variable is destroyed.</p>
      <div class="sourceCode" id="cb7"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> x<span class="op">;</span> <span class="co">// y borrows the data from x</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> x)<span class="op">;</span> <span class="co">// ERROR: x no longer has the data, y has it!</span></span></code></pre></div>
      <p>When a borrowed variable is destroyed, it gives back the
      borrowed value back to the owner.</p>
      <div class="sourceCode" id="cb8"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> x<span class="op">;</span> <span class="co">// y borrows the data from x</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>y <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// y changes the borrowed data</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// y gives back the data to x</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> x)<span class="op">;</span> <span class="co">// x has the data back again (and its changed to 6)</span></span></code></pre></div>
      <p>Because of this, the owner has to live longer than the
      borrower</p>
      <div class="sourceCode" id="cb9"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> x<span class="op">:</span> <span class="op">&amp;</span><span class="dt">i32</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="op">&amp;</span>y<span class="op">;</span> <span class="co">// ERROR: x lives longer than y!</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// y gets destroyed here! What would happen to x if the Rust compiler didn&#39;t prevent this from happening?</span></span></code></pre></div>
      <p>Tips &amp; Tricks:</p>
      <ul>
      <li>Function parameters end up mostly being borrowed references
      because otherwise the value will be moved inside the function</li>
      <li>Function return values should not be references to local
      variables and Rust will not let you do this. If you returned a
      pointer to a local value in C you could either end up with
      corrupted data or the return value won’t know when to deallocate
      its data which is bad either way you look at it</li>
      <li>Don’t worry about dereferencing to “read” or “write”
      (depending on &amp; or &amp;mut) the value of a borrowed
      reference</li>
      </ul>
      <div class="sourceCode" id="cb10"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> State <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    Hello<span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    Bye<span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> hello(blah<span class="op">:</span> <span class="op">&amp;</span>State<span class="op">,</span> foo<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="op">*</span>blah <span class="op">{</span> <span class="co">// you are only reading an immutable reference so its fine</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">State::</span>Hello <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Hello!&quot;</span>)<span class="op">,</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">State::</span>Bye <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Bye!&quot;</span>)<span class="op">,</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>foo <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// you are only writing to a mutable reference so its fine</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <ul>
      <li>Do worry about assigning dereferenced references to variables,
      because that will instead try to move the data to the new
      variable</li>
      </ul>
      <div class="sourceCode" id="cb11"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> State <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    Hello<span class="op">,</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    Bye<span class="op">,</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> hello(blah<span class="op">:</span> <span class="op">&amp;</span>State) <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> thief <span class="op">=</span> <span class="op">*</span>blah<span class="op">;</span> <span class="co">// ERROR: blah can&#39;t give a borrowed item to thief!</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                       <span class="co">// thief is going to take the value without giving it back to the original owner</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <ul>
      <li>Assignment is not the only thing that will attempt to move out
      of a borrowed reference. For example, pattern matching also tries
      to move the value. To prevent this, precede the match variable
      with ‘ref’ to borrow the match variable instead of moving</li>
      </ul>
      <div class="sourceCode" id="cb12"><pre
      class="sourceCode language-rust"><code class="sourceCode language-rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> State <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    Hello(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    Bye<span class="op">,</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> hello(blah<span class="op">:</span> <span class="op">&amp;</span>State) <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="op">*</span>blah <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">State::</span>Hello(s) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Hello, {}&quot;</span><span class="op">,</span> s)<span class="op">,</span> <span class="co">// ERROR: moves data inside blah (the string) into the variable s</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">State::</span>Bye <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Bye!&quot;</span>)<span class="op">,</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do this instead</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="op">*</span>blah <span class="op">{</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">State::</span>Hello(<span class="kw">ref</span> s) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Hello, {}&quot;</span><span class="op">,</span> s)<span class="op">,</span> <span class="co">// borrow the string data inside blah</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">State::</span>Bye <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Bye!&quot;</span>)<span class="op">,</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h2 id="lifetimes">Lifetimes</h2>
      <p>TODO: write this later</p>
    </div>
  </div>
  <script src="static/js/prism.js"></script>
</body>


</html>